# an failed prototype code generated by chatgpt or deepseek midi to cye
import mido
from mido import MidiFile

def generate_delay_bytes(delay, base_delay=100, use_smart_delay=True):
    """
    Convert delay into hex byte(s). Supports:
    - smart delay: 0x81–0xFE (each byte = delay unit)
    - fallback: repeated 0x81 (unit)
    """
    delay_bytes = []
    while delay >= base_delay:
        units = min(delay // base_delay, 0x7E)
        byte = 0x80 + units if use_smart_delay else 0x81
        delay_bytes.append(f"{byte:02X}")
        delay -= units * base_delay if use_smart_delay else base_delay
    return delay_bytes

def midi_to_hex(
    midi_file_path,
    output_text_file,
    ticks_per_beat=480,
    base_delay=100,
    use_smart_delay=True,
    note_base=12,         # MIDI note 12 (C0) → hex 00
    note_shift=0,         # Shift in semitones (can be negative)
    note_min=0x00,
    note_max=0x5F
):
    try:
        mid = MidiFile(midi_file_path, ticks_per_beat=ticks_per_beat)
        hex_tracks = []

        for track_index, track in enumerate(mid.tracks):
            abs_time = 100
            prev_time = 100
            hex_track = []
            first_note_added = False
            warning_flag = False

            for msg in track:
                abs_time += msg.time

                if msg.type == 'note_on' and msg.velocity > 0:
                    delay = abs_time - prev_time
                    if delay >= base_delay:
                        hex_track.extend(generate_delay_bytes(delay, base_delay, use_smart_delay))

                    # Apply shift and remap
                    shifted_note = msg.note + note_shift - note_base

                    if note_min <= shifted_note <= note_max:
                        hex_track.append(f"{shifted_note:02X}")
                    else:
                        hex_track.append("61")  # Placeholder for out-of-range note
                        warning_flag = True

                    prev_time = abs_time
                    first_note_added = True

            final_delay = abs_time - prev_time
            if first_note_added and final_delay >= base_delay:
                hex_track.extend(generate_delay_bytes(final_delay, base_delay, use_smart_delay))

            track_output = f"// Track {track_index}\n" + ' '.join(hex_track)
            if warning_flag:
                track_output += "\n// Warning: hex notes out of range (note_min–note_max exceeded)"
            hex_tracks.append(track_output)

        with open(output_text_file, 'w') as f:
            for track in hex_tracks:
                f.write(track + "\n\n")

        print(f"✅ MIDI converted successfully. Output saved to '{output_text_file}'")

    except Exception as e:
        print(f"❌ Error: {e}")

# ----------- Shared Settings (Only Update Here!) ----------------
settings = {
    "midi_file_path": "input.mid",
    "output_text_file": "output_hex_smart_duration.txt",
    "ticks_per_beat": 480,
    "base_delay": 100,
    "use_smart_delay": False,
    "note_base": 12,     # MIDI note 12 (C0) maps to hex 00
    "note_shift": 0,     # Transpose if needed
    "note_min": 0x00,    # Allowed hex note range
    "note_max": 0x5F
}

# Run conversion with synced settings
if __name__ == "__main__":
    midi_to_hex(**settings)
